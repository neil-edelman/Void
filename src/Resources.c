/** Copyright 2014 Neil Edelman, distributed under the terms of the
 GNU General Public License, see copying.txt

 This is a crude static database.

 @author Neil
 @version 1
 @since 2014 */

#include <stdlib.h> /* malloc free */
#include <stdio.h>  /* fprintf */
#include <string.h> /* strcmp */
#include "Math.h"
#include "Open.h"   /* bitmap */
#include "Resources.h"

/* hard coded resouce files; there should be the directory tools/ where you can
 compile utilities that can make these files; run "make" and this should be
 automated */
#include "../bin/objects_in_space_tsv.h"
#include "../bin/type_of_object_tsv.h"
#include "../bin/ship_class_tsv.h"
#include "../bin/alignment_tsv.h"

/* include hard-coded resources generated by tools/, see Makefile */
#include "../bin/Ngc4038_4039_bmp.h"
#include "../bin/Asteroid_bmp.h"
#include "../bin/Nautilus_bmp.h"
#include "../bin/Scorpion_bmp.h"

struct Resources {
	int           no_bitmaps;
	struct Bitmap *bitmap[4];
	int           enum_ois;
};

void resolve_foreign_keys(const struct Resources *r);
void sort_resources(void);
int cmp_objects_in_space(const struct ObjectsInSpace *a, const struct ObjectsInSpace *b);
int cmp_type_of_object(const struct TypeOfObject *a, const struct TypeOfObject *b);
int cmp_ship_class(const struct ShipClass *a, const struct ShipClass *b);
int cmp_alignment(const struct Alignment *a, const struct Alignment *b);
void print_objects_in_space(const struct ObjectsInSpace *a);
void print_type_of_object(const struct TypeOfObject *a);
struct Bitmap *Bitmap(const char *name, const int width, const int height, const int depth, const unsigned char *bmp);
void Bitmap_(struct Bitmap **b_ptr);
int cmp_bitmap(const struct Bitmap **a, const struct Bitmap **b);
void print_bitmap(const struct Bitmap *a);

/* public */

/** constructor
 @return an object or a null pointer if the object couldn't be created */
struct Resources *Resources(void) {
	struct Resources *r;
	int i;

	if(!(r = malloc(sizeof(struct Resources)))) {
		perror("Resources constructor");
		Resources_(&r);
		return 0;
	}
	/* the bitmaps are special */
	r->no_bitmaps = 4;
	r->bitmap[0]  = Bitmap(Ngc4038_4039_bmp_name, Ngc4038_4039_bmp_width, Ngc4038_4039_bmp_height, Ngc4038_4039_bmp_depth, Ngc4038_4039_bmp_bmp);
	r->bitmap[1]  = Bitmap(Asteroid_bmp_name, Asteroid_bmp_width, Asteroid_bmp_height, Asteroid_bmp_depth, Asteroid_bmp_bmp);
	r->bitmap[2]  = Bitmap(Nautilus_bmp_name, Nautilus_bmp_width, Nautilus_bmp_height, Nautilus_bmp_depth, Nautilus_bmp_bmp);
	r->bitmap[3]  = Bitmap(Scorpion_bmp_name, Scorpion_bmp_width, Scorpion_bmp_height, Scorpion_bmp_depth, Scorpion_bmp_bmp);
	qsort(r->bitmap, r->no_bitmaps, sizeof(struct Bitmap *), (int (*)(const void *, const void *))&cmp_bitmap);
	fprintf(stderr, "sorted bitmaps:\n");
	for(i = 0; i < r->no_bitmaps; i++) print_bitmap(r->bitmap[i]);
	sort_resources();
	resolve_foreign_keys(r);
	fprintf(stderr, "Resources: new, #%p.\n", (void *)r);

	return r;
}

/** destructor
 @param r_ptr a reference to the object that is to be deleted */
void Resources_(struct Resources **r_ptr) {
	struct Resources *r;

	if(!r_ptr || !(r = *r_ptr)) return;
	Bitmap_(&r->bitmap[0]);
	Bitmap_(&r->bitmap[1]);
	Bitmap_(&r->bitmap[2]);
	Bitmap_(&r->bitmap[3]);
	fprintf(stderr, "~Resources: erase, #%p.\n", (void *)r);
	free(r);
	*r_ptr = r = 0;
}

struct Bitmap *ResourcesFindBitmap(const struct Resources *r, const char *name) {
	int i;

	if(!r) return 0;
	/* fixme */
	for(i = 0; i < r->no_bitmaps; i++) {
		if(!strcmp(name, r->bitmap[i]->name)) return r->bitmap[i];
	}
	return 0;
}

struct ObjectsInSpace *ResourcesEnumObjectsInSpace(struct Resources *r) {
	if(!r) return 0;
	if(r->enum_ois >= no_objects_in_space) {
		r->enum_ois = 0;
		return 0;
	}
	return &objects_in_space[r->enum_ois++];
}

/** resolve foreign keys on sorted array */
void resolve_foreign_keys(const struct Resources *r) {
	struct Bitmap **bitmap_ptr, *bitmap;
	struct TypeOfObject *too;
	struct ObjectsInSpace *ois;
	struct ShipClass *sc;
	struct Alignment *al, *al2;
	int i, first;
	char **str_ptr;

	fprintf(stderr, "Resolving foreign keys:\n");

	/* type_of_object: resolve bitmap */
	fprintf(stderr, "type_of_object: ");
	for(i = 0, first = -1; i < no_type_of_object; i++) {
		too = &type_of_object[i];
		if(first) {
			first = 0;
		} else {
			fprintf(stderr, ", ");
		}
		fprintf(stderr, "%s", too->name);
		str_ptr = &too->bmp_name;
		bitmap_ptr = (struct Bitmap **)bsearch(&str_ptr, r->bitmap, r->no_bitmaps, sizeof(struct Bitmap *), (int (*)(const void *, const void *))&cmp_bitmap);
		if(bitmap_ptr) {
			bitmap = *bitmap_ptr;
			too->bmp = bitmap;
			/*fprintf(stderr, "type_of_object %s has %s which is associated with %s\n", too->name, too->bmp_name, item->name);*/
		} else {
			fprintf(stderr, "Resources::resolve_foreign_keys: unresolved reference from type_of_object \"%s\" bitmap \"%s;\" setting null.\n", too->name, too->bmp_name);
		}
	}
	fprintf(stderr, "\n");
	for(i = 0; i < no_type_of_object; i++) print_type_of_object(&type_of_object[i]);
	/*fprintf(stderr, "type_of_object\t%s\t%s\t%d\n", type_of_object[i].name, type_of_object[i].bmp_name, type_of_object[i].bmp);*/

	/* objects_in_space: resolve type_of_object */
	fprintf(stderr, "objects_in_space: ");
	for(i = 0, first = -1; i < no_objects_in_space; i++) {
		ois = &objects_in_space[i];
		if(first) {
			first = 0;
		} else {
			fprintf(stderr, ", ");
		}
		fprintf(stderr, "%d", ois->id);
		str_ptr = &ois->type_name;
		too = (struct TypeOfObject *)bsearch(str_ptr, type_of_object, no_type_of_object, sizeof(struct TypeOfObject), (int (*)(const void *, const void *))&cmp_type_of_object);
		if(too) {
			ois->type = too;
			/*fprintf(stderr, "objects_in_space %d has \"%s\" which is associated with %s\n", ois->id, ois->type_name, too->name);*/
		} else {
			fprintf(stderr, "Resources::resolve_foreign_keys: unresolved reference from objects_in_space %d type_of_object \"%s;\" setting null.\n", ois->id, ois->type_name);
			/* FIXME SET TYPE TO STH! */
		}
	}
	fprintf(stderr, "\n");
	for(i = 0; i < no_objects_in_space; i++) print_objects_in_space(&objects_in_space[i]);
	/*fprintf(stderr, "objects_in_space\t%d\t%s\t%s\n", objects_in_space[i].id, objects_in_space[i].type_name, objects_in_space[i].type ? objects_in_space[i].type->name : "null");*/

	/* ship_class: resolve bmp_name */
	fprintf(stderr, "ship_class: ");
	for(i = 0, first = -1; i < no_ship_class; i++) {
		sc = &ship_class[i];
		if(first) {
			first = 0;
		} else {
			fprintf(stderr, ", ");
		}
		fprintf(stderr, "%s", sc->bmp_name);
		str_ptr = &sc->bmp_name;
		bitmap_ptr = (struct Bitmap **)bsearch(&str_ptr, r->bitmap, r->no_bitmaps, sizeof(struct Bitmap *), (int (*)(const void *, const void *))&cmp_bitmap);
		if(bitmap_ptr) {
			bitmap = *bitmap_ptr;
			sc->bmp = bitmap;
		} else {
			fprintf(stderr, "Resources::resolve_foreign_keys: unresolved reference from ship_class %s \"%s;\" setting null.\n", sc->name, sc->bmp_name);
		}
	}
	fprintf(stderr, "\n");
	for(i = 0; i < no_ship_class; i++) {
		sc = &ship_class[i];
		fprintf(stderr, "%s\t%s\t%d\t%d\n", sc->bmp_name, sc->bmp ? sc->bmp->name : "null", sc->shield, sc->msShield);
	}

	/* alignment: resolve hates and likes */
	fprintf(stderr, "alignment: ");
	for(i = 0, first = -1; i < no_alignment; i++) {
		al = &alignment[i];
		if(first) {
			first = 0;
		} else {
			fprintf(stderr, ", ");
		}
		fprintf(stderr, "%s", al->name);
		str_ptr = &al->hates_name;
		al2 = (struct Alignment *)bsearch(str_ptr, alignment, no_alignment, sizeof(struct Alignment), (int (*)(const void *, const void *))&cmp_alignment);
		if(too) {
			al->hates = al2;
		} else {
			fprintf(stderr, "Resources::resolve_foreign_keys: unresolved reference from alignment %s hates \"%s;\" setting null.\n", al->name, al->hates_name);
		}
	}
	fprintf(stderr, "\n");
	for(i = 0; i < no_alignment; i++) {
		al = &alignment[i];
		fprintf(stderr, "%s\t%s\t%s\n", al->name, al->hates ? al->hates->name : "null", al->likes ? al->likes->name : "null");
	}

}

void sort_resources(void) {
	int i;

	fprintf(stderr, "Sorting resources:\n");
	for(i = 0; i < no_type_of_object; i++) print_type_of_object(&type_of_object[i]);
	for(i = 0; i < no_objects_in_space; i++) print_objects_in_space(&objects_in_space[i]);
	qsort(type_of_object, no_type_of_object, sizeof(struct TypeOfObject), (int (*)(const void *, const void *))&cmp_type_of_object);
	qsort(objects_in_space, no_objects_in_space, sizeof(struct ObjectsInSpace), (int (*)(const void *, const void *))&cmp_objects_in_space);
	qsort(ship_class, no_ship_class, sizeof(struct ShipClass), (int (*)(const void *, const void *))&cmp_ship_class);
	qsort(alignment, no_alignment, sizeof(struct Alignment), (int (*)(const void *, const void *))&cmp_alignment);
	fprintf(stderr, "done:\n");
	for(i = 0; i < no_type_of_object; i++) print_type_of_object(&type_of_object[i]);
	for(i = 0; i < no_objects_in_space; i++) print_objects_in_space(&objects_in_space[i]);
}

int cmp_objects_in_space(const struct ObjectsInSpace *a, const struct ObjectsInSpace *b) {
	return a->id - b->id;
}

int cmp_type_of_object(const struct TypeOfObject *a, const struct TypeOfObject *b) {
	return strcmp(a->name, b->name);
}

int cmp_ship_class(const struct ShipClass *a, const struct ShipClass *b) {
	return strcmp(a->bmp_name, b->bmp_name);
}

int cmp_alignment(const struct Alignment *a, const struct Alignment *b) {
	return strcmp(a->name, b->name);
}

void print_objects_in_space(const struct ObjectsInSpace *a) {
	fprintf(stderr, "object in space: id %d, type '%s' (#%p) at (%f, %f)\n", a->id, a->type_name, (void *)a->type, a->position.x, a->position.y);
}

void print_type_of_object(const struct TypeOfObject *a) {
	fprintf(stderr, "type of object: name %s, bmp '%s' (%s)\n", a->name, a->bmp_name, a->bmp ? a->bmp->name : "null");
}

/* private */

/** constructor
 @return a Bitmap or a null pointer if the object couldn't be created */
struct Bitmap *Bitmap(const char *name, const int width, const int height, const int depth, const unsigned char *bmp) {
	int id;
	struct Bitmap *b;

	if(!name || width <= 0 || height <= 0 || depth <= 0 || !bmp) {
		fprintf(stderr, "Bitmap: '%s' invalid.\n", name);
		return 0;
	}
	if(!(id = OpenTexture(width, height, depth, bmp))) return 0;
	if(!(b = malloc(sizeof(struct Bitmap)))) {
		perror("Bitmap constructor");
		Bitmap_(&b);
		OpenTexture_(id);
		return 0;
	}
	b->id     = id;
	b->name   = (char *)name;
	b->width  = width;
	b->height = height;
	b->depth  = depth;
	fprintf(stderr, "Bitmap: new \"%s;\" texture %dx%dx%d assigned %u, #%p.\n", name, width, height, depth, id, (void *)b);

	return b;
}

/** destructor
 @param b_ptr a reference to the object that is to be deleted */
void Bitmap_(struct Bitmap **b_ptr) {
	struct Bitmap *b;
	
	if(!b_ptr || !(b = *b_ptr)) return;
	OpenTexture_(b->id);
	fprintf(stderr, "~Bitmap: erase %d, #%p.\n", b->id, (void *)b);
	free(b);
	*b_ptr = b = 0;
}

int cmp_bitmap(const struct Bitmap **a, const struct Bitmap **b) {
	return strcmp((*a)->name, (*b)->name);
}

void print_bitmap(const struct Bitmap *a) {
	fprintf(stderr, "bitmap: name '%s' id %d\n", a->name, a->id);
}
