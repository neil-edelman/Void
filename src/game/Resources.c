/* Copyright 2014, 2015 Neil Edelman, distributed under the terms of the
 GNU General Public License, see copying.txt */

#include <stdlib.h> /* malloc free */
#include <stdio.h>  /* fprintf */
#include <string.h> /* strcmp */
#include "../general/Map.h" /* Automator */
#include "../general/Image.h" /* Automator */
#include "Resources.h"

/* potentally huge -- lazy cheat code generation! include hard-coded bitmaps,
 tsv, etc, generated by tools/Automator/, see Makefile; this accounts for 99%
 of the compilation time because all the resources as .h have to be included */
#include "../../bin/Automator.c" /* automator() */

/** This is a crude static database.

 @author	Neil
 @version	3.2, 2015-07
 @since		1,   2014 (?) */

static int is_started;

/* these have special meaning; associate Field with fields */
enum Field {
	FOREIGN,
	AUTOINCREMENT,
	INT,
	STRING,
	FLOAT,
	IMAGE
};
static const char *const fields[] = {
	"foreign",
	"autoincrement",
	"int",
	"string",
	"float",
	"image"
};

static struct Record {
	char *resource_name;
	enum Field key;
	unsigned no_fields;
	enum Field fields[16];
} records[64];
static const int max_record_fields = sizeof((struct Record *)0)->fields / sizeof(enum Field);
static const int max_records = sizeof(records) / sizeof(struct Record);

/* 6. make a new map in the resources; eg, struct Map *foo_bar; */
struct Resources {
	struct Map *image;
	/*struct Map *tsv; fixme */
	struct Map *type_of_object;
	struct Map *objects_in_space;
	struct Map *ship_class;
	struct Map *alignment;
} resources;

/*void resolve_foreign_keys(void);
void sort_resources(void);
int cmp_objects_in_space(const struct ObjectsInSpace *a, const struct ObjectsInSpace *b);
int cmp_type_of_object(const struct TypeOfObject *a, const struct TypeOfObject *b);
int cmp_ship_class(const struct ShipClass *a, const struct ShipClass *b);
int cmp_alignment(const struct Alignment *a, const struct Alignment *b);
void print_objects_in_space(const struct ObjectsInSpace *a);
void print_type_of_object(const struct TypeOfObject *a);
struct Bitmap *Bitmap(const char *name, const int width, const int height, const int depth, const unsigned char *bmp);
void Bitmap_(struct Bitmap **b_ptr);
int cmp_bitmap(const struct Bitmap **a, const struct Bitmap **b);
void print_bitmap(const struct Bitmap *a);*/
static void delete_image(char *key, struct Image *img);
static void delete_resource(char *key, void *text);

/* public */

/** Loads all resources. There is only one resources object; if it was already
 loaded, returns true.
 @return	True on success. */
int Resources(void) {

	if(is_started) return -1;

	/* initialise
	 7. add an initialisation; eg, ...|| !(resources.foo_bar = Map("foo bar", (int (*)(const void *, const void *))...))... */
	if(!(resources.image = Map("images", (int (*)(const void *, const void *))strcmp))
	   || !(resources.type_of_object = Map("type of object", (int (*)(const void *, const void *))strcmp))
	   || !(resources.objects_in_space = Map("objects in space", (int (*)(const void *, const void *))strcmp/*fixme danger*/))
	   || !(resources.type_of_object = Map("ship class", (int (*)(const void *, const void *))strcmp))
	   || !(resources.alignment = Map("alignment", (int (*)(const void *, const void *))strcmp))
	   ) return 0;
	/* all of them have destructors
	 8. add a destructor; eg, MapSetDestructor(resources.foo_bar, (void (*)(void *, void *))delete_resource); */
	MapSetDestructor(resources.image, (void (*)(void *, void *))delete_image);
	MapSetDestructor(resources.type_of_object, (void (*)(void *, void *))delete_resource);
	MapSetDestructor(resources.objects_in_space, (void (*)(void *, void *))delete_resource);
	MapSetDestructor(resources.type_of_object, (void (*)(void *, void *))delete_resource);
	MapSetDestructor(resources.alignment, (void (*)(void *, void *))delete_resource);

	/* load in all bitmaps by hand!; fixme: compress! fixme: bmp is crap; store
	 jpeg (backgrounds) and png (sprites;) use the code from sb else, too much
	 work */
	/* fuck that, this is in Automator.c, generated automatically */
	if(!AutomatorImages(resources.image)) {
		Resources_();
		return 0;
	}

	/* debug */{
		char *key;
		while(MapIterate(resources.image, (const void **)&key, 0)) fprintf(stderr, "%s\n", key);
	}

	/*resolve_foreign_keys(r);*/

	fprintf(stderr, "Resources: loaded all resources at #%p.\n", (void *)&resources);
	is_started = -1;

	return -1;
}

/** Destructor. */
void Resources_(void) {
	if(!is_started) return;
	/* 9. add a destuctor for the map */
	Map_(&resources.alignment);
	Map_(&resources.ship_class);
	Map_(&resources.objects_in_space);
	Map_(&resources.type_of_object);
	Map_(&resources.image);
	is_started = 0;
	fprintf(stderr, "~Resources: erase #%p.\n", (void *)&resources);
}

struct Map *ResourcesGetImages(void) { /* fixme: no? */
	if(!is_started) return 0;
	return resources.image;
}

#if 0

/** resolve foreign keys on sorted array */
void resolve_foreign_keys(const struct Resources *r) {
	struct Bitmap **bitmap_ptr, *bitmap;
	struct TypeOfObject *too;
	struct ObjectsInSpace *ois;
	struct ShipClass *sc;
	struct Alignment *al, *al2;
	int i, first;
	char **str_ptr;

	fprintf(stderr, "Resolving foreign keys:\n");

	/* type_of_object: resolve bitmap */
	fprintf(stderr, "type_of_object: ");
	for(i = 0, first = -1; i < no_type_of_object; i++) {
		too = &type_of_object[i];
		if(first) {
			first = 0;
		} else {
			fprintf(stderr, ", ");
		}
		fprintf(stderr, "%s", too->name);
		str_ptr = &too->bmp_name;
		bitmap_ptr = (struct Bitmap **)bsearch(&str_ptr, r->bitmap, r->no_bitmaps, sizeof(struct Bitmap *), (int (*)(const void *, const void *))&cmp_bitmap);
		if(bitmap_ptr) {
			bitmap = *bitmap_ptr;
			too->bmp = bitmap;
			/*fprintf(stderr, "type_of_object %s has %s which is associated with %s\n", too->name, too->bmp_name, item->name);*/
		} else {
			fprintf(stderr, "Resources::resolve_foreign_keys: unresolved reference from type_of_object \"%s\" bitmap \"%s;\" setting null.\n", too->name, too->bmp_name);
		}
	}
	fprintf(stderr, "\n");
	for(i = 0; i < no_type_of_object; i++) print_type_of_object(&type_of_object[i]);
	/*fprintf(stderr, "type_of_object\t%s\t%s\t%d\n", type_of_object[i].name, type_of_object[i].bmp_name, type_of_object[i].bmp);*/

	/* objects_in_space: resolve type_of_object */
	fprintf(stderr, "objects_in_space: ");
	for(i = 0, first = -1; i < no_objects_in_space; i++) {
		ois = &objects_in_space[i];
		if(first) {
			first = 0;
		} else {
			fprintf(stderr, ", ");
		}
		fprintf(stderr, "%d", ois->id);
		str_ptr = &ois->type_name;
		too = (struct TypeOfObject *)bsearch(str_ptr, type_of_object, no_type_of_object, sizeof(struct TypeOfObject), (int (*)(const void *, const void *))&cmp_type_of_object);
		if(too) {
			ois->type = too;
			/*fprintf(stderr, "objects_in_space %d has \"%s\" which is associated with %s\n", ois->id, ois->type_name, too->name);*/
		} else {
			fprintf(stderr, "Resources::resolve_foreign_keys: unresolved reference from objects_in_space %d type_of_object \"%s;\" setting null.\n", ois->id, ois->type_name);
			/* FIXME SET TYPE TO STH! */
		}
	}
	fprintf(stderr, "\n");
	for(i = 0; i < no_objects_in_space; i++) print_objects_in_space(&objects_in_space[i]);
	/*fprintf(stderr, "objects_in_space\t%d\t%s\t%s\n", objects_in_space[i].id, objects_in_space[i].type_name, objects_in_space[i].type ? objects_in_space[i].type->name : "null");*/

	/* ship_class: resolve bmp_name */
	fprintf(stderr, "ship_class: ");
	for(i = 0, first = -1; i < no_ship_class; i++) {
		sc = &ship_class[i];
		if(first) {
			first = 0;
		} else {
			fprintf(stderr, ", ");
		}
		fprintf(stderr, "%s", sc->bmp_name);
		str_ptr = &sc->bmp_name;
		bitmap_ptr = (struct Bitmap **)bsearch(&str_ptr, r->bitmap, r->no_bitmaps, sizeof(struct Bitmap *), (int (*)(const void *, const void *))&cmp_bitmap);
		if(bitmap_ptr) {
			bitmap = *bitmap_ptr;
			sc->bmp = bitmap;
		} else {
			fprintf(stderr, "Resources::resolve_foreign_keys: unresolved reference from ship_class %s \"%s;\" setting null.\n", sc->name, sc->bmp_name);
		}
	}
	fprintf(stderr, "\n");
	for(i = 0; i < no_ship_class; i++) {
		sc = &ship_class[i];
		fprintf(stderr, "%s\t%s\t%d\t%d\n", sc->bmp_name, sc->bmp ? sc->bmp->name : "null", sc->shield, sc->msShield);
	}

	/* alignment: resolve hates and likes */
	fprintf(stderr, "alignment: ");
	for(i = 0, first = -1; i < no_alignment; i++) {
		al = &alignment[i];
		if(first) {
			first = 0;
		} else {
			fprintf(stderr, ", ");
		}
		fprintf(stderr, "%s", al->name);
		str_ptr = &al->hates_name;
		al2 = (struct Alignment *)bsearch(str_ptr, alignment, no_alignment, sizeof(struct Alignment), (int (*)(const void *, const void *))&cmp_alignment);
		if(too) {
			al->hates = al2;
		} else {
			fprintf(stderr, "Resources::resolve_foreign_keys: unresolved reference from alignment %s hates \"%s;\" setting null.\n", al->name, al->hates_name);
		}
	}
	fprintf(stderr, "\n");
	for(i = 0; i < no_alignment; i++) {
		al = &alignment[i];
		fprintf(stderr, "%s\t%s\t%s\n", al->name, al->hates ? al->hates->name : "null", al->likes ? al->likes->name : "null");
	}

}

void sort_resources(void) {
	int i;

	fprintf(stderr, "Sorting resources:\n");
	for(i = 0; i < no_type_of_object; i++) print_type_of_object(&type_of_object[i]);
	for(i = 0; i < no_objects_in_space; i++) print_objects_in_space(&objects_in_space[i]);
	qsort(type_of_object, no_type_of_object, sizeof(struct TypeOfObject), (int (*)(const void *, const void *))&cmp_type_of_object);
	qsort(objects_in_space, no_objects_in_space, sizeof(struct ObjectsInSpace), (int (*)(const void *, const void *))&cmp_objects_in_space);
	qsort(ship_class, no_ship_class, sizeof(struct ShipClass), (int (*)(const void *, const void *))&cmp_ship_class);
	qsort(alignment, no_alignment, sizeof(struct Alignment), (int (*)(const void *, const void *))&cmp_alignment);
	fprintf(stderr, "done:\n");
	for(i = 0; i < no_type_of_object; i++) print_type_of_object(&type_of_object[i]);
	for(i = 0; i < no_objects_in_space; i++) print_objects_in_space(&objects_in_space[i]);
}

/*int cmp_objects_in_space(const struct ObjectsInSpace *a, const struct ObjectsInSpace *b) {
	return a->id - b->id;
}

int cmp_type_of_object(const struct TypeOfObject *a, const struct TypeOfObject *b) {
	return strcmp(a->name, b->name);
}

int cmp_ship_class(const struct ShipClass *a, const struct ShipClass *b) {
	return strcmp(a->bmp_name, b->bmp_name);
}

int cmp_alignment(const struct Alignment *a, const struct Alignment *b) {
	return strcmp(a->name, b->name);
}

void print_objects_in_space(const struct ObjectsInSpace *a) {
	fprintf(stderr, "object in space: id %d, type '%s' (#%p) at (%f, %f)\n", a->id, a->type_name, (void *)a->type, a->position.x, a->position.y);
}

void print_type_of_object(const struct TypeOfObject *a) {
	fprintf(stderr, "type of object: name %s, bmp '%s' (%s)\n", a->name, a->bmp_name, a->bmp ? a->bmp->name : "null");
}*/

/* private */

/** constructor
 @return a Bitmap or a null pointer if the object couldn't be created */
struct Bitmap *Bitmap(const char *name, const int width, const int height, const int depth, const unsigned char *bmp) {
	int id;
	struct Bitmap *b;

	if(!name || width <= 0 || height <= 0 || depth <= 0 || !bmp) {
		fprintf(stderr, "Bitmap: '%s' invalid.\n", name);
		return 0;
	}
	if(!(id = OpenTexture(width, height, depth, bmp))) return 0;
	if(!(b = malloc(sizeof(struct Bitmap)))) {
		perror("Bitmap constructor");
		Bitmap_(&b);
		OpenTexture_(id);
		return 0;
	}
	b->id     = id;
	b->name   = (char *)name;
	b->width  = width;
	b->height = height;
	b->depth  = depth;
	fprintf(stderr, "Bitmap: new \"%s;\" texture %dx%dx%d assigned %u, #%p.\n", name, width, height, depth, id, (void *)b);

	return b;
}

/** destructor
 @param b_ptr a reference to the object that is to be deleted */
void Bitmap_(struct Bitmap **b_ptr) {
	struct Bitmap *b;
	
	if(!b_ptr || !(b = *b_ptr)) return;
	OpenTexture_(b->id);
	fprintf(stderr, "~Bitmap: erase %d, #%p.\n", b->id, (void *)b);
	free(b);
	*b_ptr = b = 0;
}

int cmp_bitmap(const struct Bitmap **a, const struct Bitmap **b) {
	return strcmp((*a)->name, (*b)->name);
}

void print_bitmap(const struct Bitmap *a) {
	fprintf(stderr, "bitmap: name '%s' id %d\n", a->name, a->id);
}
#endif

/** callback for deleting from the map */
static void delete_image(char *key, struct Image *img) { Image_(&img); }
static void delete_resource(char *key, void *text) {
	fprintf(stderr, "~resource: deleting resource at #%p.\n", text);
	free(text);
}
